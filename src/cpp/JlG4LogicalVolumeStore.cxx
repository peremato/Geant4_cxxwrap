// this file was auto-generated by wrapit v1.3.1-15-g5168a24
#include "Wrapper.h"

#include "jlGeant4.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {
  template<> struct IsMirroredType<G4LogicalVolumeStore> : std::false_type { };
  template<> struct DefaultConstructible<G4LogicalVolumeStore> : std::false_type { };
}

// Class generating the wrapper for type G4LogicalVolumeStore
// signature to use in the veto file: G4LogicalVolumeStore
struct JlG4LogicalVolumeStore: public Wrapper {

  JlG4LogicalVolumeStore(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type G4LogicalVolumeStore (" __HERE__ ")");
    // defined in /Users/mato/.julia/artifacts/c08a070cdc1b892bb33db4924fdac1694e77d3a1/include/Geant4/G4LogicalVolumeStore.hh:55:7
    jlcxx::TypeWrapper<G4LogicalVolumeStore>  t = jlModule.add_type<G4LogicalVolumeStore>("G4LogicalVolumeStore");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<G4LogicalVolumeStore>>(new jlcxx::TypeWrapper<G4LogicalVolumeStore>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for void G4LogicalVolumeStore::Register(G4LogicalVolume *) (" __HERE__ ")");
    // signature to use in the veto list: void G4LogicalVolumeStore::Register(G4LogicalVolume *)
    // defined in /Users/mato/.julia/artifacts/c08a070cdc1b892bb33db4924fdac1694e77d3a1/include/Geant4/G4LogicalVolumeStore.hh:59:17
    module_.method("G4LogicalVolumeStore!Register", static_cast<void (*)(G4LogicalVolume *) >(&G4LogicalVolumeStore::Register));

    DEBUG_MSG("Adding wrapper for void G4LogicalVolumeStore::DeRegister(G4LogicalVolume *) (" __HERE__ ")");
    // signature to use in the veto list: void G4LogicalVolumeStore::DeRegister(G4LogicalVolume *)
    // defined in /Users/mato/.julia/artifacts/c08a070cdc1b892bb33db4924fdac1694e77d3a1/include/Geant4/G4LogicalVolumeStore.hh:61:17
    module_.method("G4LogicalVolumeStore!DeRegister", static_cast<void (*)(G4LogicalVolume *) >(&G4LogicalVolumeStore::DeRegister));

    DEBUG_MSG("Adding wrapper for G4LogicalVolumeStore * G4LogicalVolumeStore::GetInstance() (" __HERE__ ")");
    // signature to use in the veto list: G4LogicalVolumeStore * G4LogicalVolumeStore::GetInstance()
    // defined in /Users/mato/.julia/artifacts/c08a070cdc1b892bb33db4924fdac1694e77d3a1/include/Geant4/G4LogicalVolumeStore.hh:63:34
    module_.method("G4LogicalVolumeStore!GetInstance", static_cast<G4LogicalVolumeStore * (*)() >(&G4LogicalVolumeStore::GetInstance));

    DEBUG_MSG("Adding wrapper for void G4LogicalVolumeStore::SetNotifier(G4VStoreNotifier *) (" __HERE__ ")");
    // signature to use in the veto list: void G4LogicalVolumeStore::SetNotifier(G4VStoreNotifier *)
    // defined in /Users/mato/.julia/artifacts/c08a070cdc1b892bb33db4924fdac1694e77d3a1/include/Geant4/G4LogicalVolumeStore.hh:65:17
    module_.method("G4LogicalVolumeStore!SetNotifier", static_cast<void (*)(G4VStoreNotifier *) >(&G4LogicalVolumeStore::SetNotifier));

    DEBUG_MSG("Adding wrapper for void G4LogicalVolumeStore::Clean() (" __HERE__ ")");
    // signature to use in the veto list: void G4LogicalVolumeStore::Clean()
    // defined in /Users/mato/.julia/artifacts/c08a070cdc1b892bb33db4924fdac1694e77d3a1/include/Geant4/G4LogicalVolumeStore.hh:67:17
    module_.method("G4LogicalVolumeStore!Clean", static_cast<void (*)() >(&G4LogicalVolumeStore::Clean));

    DEBUG_MSG("Adding wrapper for G4LogicalVolume * G4LogicalVolumeStore::GetVolume(const G4String &, G4bool, G4bool) (" __HERE__ ")");
    // signature to use in the veto list: G4LogicalVolume * G4LogicalVolumeStore::GetVolume(const G4String &, G4bool, G4bool)
    // defined in /Users/mato/.julia/artifacts/c08a070cdc1b892bb33db4924fdac1694e77d3a1/include/Geant4/G4LogicalVolumeStore.hh:70:22
    t.method("GetVolume", static_cast<G4LogicalVolume * (G4LogicalVolumeStore::*)(const G4String &, G4bool, G4bool)  const>(&G4LogicalVolumeStore::GetVolume));
    t.method("GetVolume", [](G4LogicalVolumeStore const& a, const G4String & arg0)->G4LogicalVolume * { return a.GetVolume(arg0); });
    t.method("GetVolume", [](G4LogicalVolumeStore const& a, const G4String & arg0, G4bool arg1)->G4LogicalVolume * { return a.GetVolume(arg0, arg1); });
    t.method("GetVolume", [](G4LogicalVolumeStore const* a, const G4String & arg0)->G4LogicalVolume * { return a->GetVolume(arg0); });
    t.method("GetVolume", [](G4LogicalVolumeStore const* a, const G4String & arg0, G4bool arg1)->G4LogicalVolume * { return a->GetVolume(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for G4bool G4LogicalVolumeStore::IsMapValid() (" __HERE__ ")");
    // signature to use in the veto list: G4bool G4LogicalVolumeStore::IsMapValid()
    // defined in /Users/mato/.julia/artifacts/c08a070cdc1b892bb33db4924fdac1694e77d3a1/include/Geant4/G4LogicalVolumeStore.hh:76:19
    t.method("IsMapValid", static_cast<G4bool (G4LogicalVolumeStore::*)()  const>(&G4LogicalVolumeStore::IsMapValid));

    DEBUG_MSG("Adding wrapper for void G4LogicalVolumeStore::SetMapValid(G4bool) (" __HERE__ ")");
    // signature to use in the veto list: void G4LogicalVolumeStore::SetMapValid(G4bool)
    // defined in /Users/mato/.julia/artifacts/c08a070cdc1b892bb33db4924fdac1694e77d3a1/include/Geant4/G4LogicalVolumeStore.hh:77:17
    t.method("SetMapValid", static_cast<void (G4LogicalVolumeStore::*)(G4bool) >(&G4LogicalVolumeStore::SetMapValid));

    DEBUG_MSG("Adding wrapper for void G4LogicalVolumeStore::UpdateMap() (" __HERE__ ")");
    // signature to use in the veto list: void G4LogicalVolumeStore::UpdateMap()
    // defined in /Users/mato/.julia/artifacts/c08a070cdc1b892bb33db4924fdac1694e77d3a1/include/Geant4/G4LogicalVolumeStore.hh:82:10
    t.method("UpdateMap", static_cast<void (G4LogicalVolumeStore::*)() >(&G4LogicalVolumeStore::UpdateMap));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<G4LogicalVolumeStore>> type_;
};
std::shared_ptr<Wrapper> newJlG4LogicalVolumeStore(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlG4LogicalVolumeStore(module));
}
