// this file was auto-generated by wrapit 5168a24-dirty
#include "Wrapper.h"

#include "jlGeant4.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {
  template<> struct IsMirroredType<G4LVData> : std::false_type { };
  template<> struct DefaultConstructible<G4LVData> : std::false_type { };
}

// Class generating the wrapper for type G4LVData
// signature to use in the veto file: G4LVData
struct JlG4LVData: public Wrapper {

  JlG4LVData(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type G4LVData (" __HERE__ ")");
    // defined in /Users/mato/.julia/artifacts/04a1f392c53fa9913a6e32dc79e45dcf6f1dd250/include/Geant4/G4LogicalVolume.hh:128:7
    jlcxx::TypeWrapper<G4LVData>  t = jlModule.add_type<G4LVData>("G4LVData");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<G4LVData>>(new jlcxx::TypeWrapper<G4LVData>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void G4LVData::initialize() (" __HERE__ ")");
    // signature to use in the veto list: void G4LVData::initialize()
    // defined in /Users/mato/.julia/artifacts/04a1f392c53fa9913a6e32dc79e45dcf6f1dd250/include/Geant4/G4LogicalVolume.hh:136:10
    t.method("initialize", static_cast<void (G4LVData::*)() >(&G4LVData::initialize));

    DEBUG_MSG("Adding fSolid methods  to provide read access to the field fSolid (" __HERE__ ")");
    // defined in /Users/mato/.julia/artifacts/04a1f392c53fa9913a6e32dc79e45dcf6f1dd250/include/Geant4/G4LogicalVolume.hh:148:15
    // signature to use in the veto list: G4LVData::fSolid
    t.method("fSolid", [](const G4LVData& a) -> G4VSolid * { return a.fSolid; });
    t.method("fSolid", [](G4LVData& a) -> G4VSolid * { return a.fSolid; });
    t.method("fSolid", [](const G4LVData* a) -> G4VSolid * { return a->fSolid; });
    t.method("fSolid", [](G4LVData* a) -> G4VSolid * { return a->fSolid; });
    // defined in /Users/mato/.julia/artifacts/04a1f392c53fa9913a6e32dc79e45dcf6f1dd250/include/Geant4/G4LogicalVolume.hh:148:15
    // signature to use in the veto list: G4LVData::fSolid
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding fSolid! methods to provide write access to the field fSolid (" __HERE__ ")");
    t.method("fSolid!", [](G4LVData& a, G4VSolid * val) -> G4VSolid * { return a.fSolid = val; });

    DEBUG_MSG("Adding fSolid! methods to provide write access to the field fSolid (" __HERE__ ")");
    t.method("fSolid!", [](G4LVData* a, G4VSolid * val) -> G4VSolid * { return a->fSolid = val; });

    DEBUG_MSG("Adding fSensitiveDetector methods  to provide read access to the field fSensitiveDetector (" __HERE__ ")");
    // defined in /Users/mato/.julia/artifacts/04a1f392c53fa9913a6e32dc79e45dcf6f1dd250/include/Geant4/G4LogicalVolume.hh:150:27
    // signature to use in the veto list: G4LVData::fSensitiveDetector
    t.method("fSensitiveDetector", [](const G4LVData& a) -> G4VSensitiveDetector * { return a.fSensitiveDetector; });
    t.method("fSensitiveDetector", [](G4LVData& a) -> G4VSensitiveDetector * { return a.fSensitiveDetector; });
    t.method("fSensitiveDetector", [](const G4LVData* a) -> G4VSensitiveDetector * { return a->fSensitiveDetector; });
    t.method("fSensitiveDetector", [](G4LVData* a) -> G4VSensitiveDetector * { return a->fSensitiveDetector; });
    // defined in /Users/mato/.julia/artifacts/04a1f392c53fa9913a6e32dc79e45dcf6f1dd250/include/Geant4/G4LogicalVolume.hh:150:27
    // signature to use in the veto list: G4LVData::fSensitiveDetector
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding fSensitiveDetector! methods to provide write access to the field fSensitiveDetector (" __HERE__ ")");
    t.method("fSensitiveDetector!", [](G4LVData& a, G4VSensitiveDetector * val) -> G4VSensitiveDetector * { return a.fSensitiveDetector = val; });

    DEBUG_MSG("Adding fSensitiveDetector! methods to provide write access to the field fSensitiveDetector (" __HERE__ ")");
    t.method("fSensitiveDetector!", [](G4LVData* a, G4VSensitiveDetector * val) -> G4VSensitiveDetector * { return a->fSensitiveDetector = val; });

    DEBUG_MSG("Adding fFieldManager methods  to provide read access to the field fFieldManager (" __HERE__ ")");
    // defined in /Users/mato/.julia/artifacts/04a1f392c53fa9913a6e32dc79e45dcf6f1dd250/include/Geant4/G4LogicalVolume.hh:152:21
    // signature to use in the veto list: G4LVData::fFieldManager
    t.method("fFieldManager", [](const G4LVData& a) -> G4FieldManager * { return a.fFieldManager; });
    t.method("fFieldManager", [](G4LVData& a) -> G4FieldManager * { return a.fFieldManager; });
    t.method("fFieldManager", [](const G4LVData* a) -> G4FieldManager * { return a->fFieldManager; });
    t.method("fFieldManager", [](G4LVData* a) -> G4FieldManager * { return a->fFieldManager; });
    // defined in /Users/mato/.julia/artifacts/04a1f392c53fa9913a6e32dc79e45dcf6f1dd250/include/Geant4/G4LogicalVolume.hh:152:21
    // signature to use in the veto list: G4LVData::fFieldManager
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding fFieldManager! methods to provide write access to the field fFieldManager (" __HERE__ ")");
    t.method("fFieldManager!", [](G4LVData& a, G4FieldManager * val) -> G4FieldManager * { return a.fFieldManager = val; });

    DEBUG_MSG("Adding fFieldManager! methods to provide write access to the field fFieldManager (" __HERE__ ")");
    t.method("fFieldManager!", [](G4LVData* a, G4FieldManager * val) -> G4FieldManager * { return a->fFieldManager = val; });

    DEBUG_MSG("Adding fMaterial methods  to provide read access to the field fMaterial (" __HERE__ ")");
    // defined in /Users/mato/.julia/artifacts/04a1f392c53fa9913a6e32dc79e45dcf6f1dd250/include/Geant4/G4LogicalVolume.hh:154:17
    // signature to use in the veto list: G4LVData::fMaterial
    t.method("fMaterial", [](const G4LVData& a) -> G4Material * { return a.fMaterial; });
    t.method("fMaterial", [](G4LVData& a) -> G4Material * { return a.fMaterial; });
    t.method("fMaterial", [](const G4LVData* a) -> G4Material * { return a->fMaterial; });
    t.method("fMaterial", [](G4LVData* a) -> G4Material * { return a->fMaterial; });
    // defined in /Users/mato/.julia/artifacts/04a1f392c53fa9913a6e32dc79e45dcf6f1dd250/include/Geant4/G4LogicalVolume.hh:154:17
    // signature to use in the veto list: G4LVData::fMaterial
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding fMaterial! methods to provide write access to the field fMaterial (" __HERE__ ")");
    t.method("fMaterial!", [](G4LVData& a, G4Material * val) -> G4Material * { return a.fMaterial = val; });

    DEBUG_MSG("Adding fMaterial! methods to provide write access to the field fMaterial (" __HERE__ ")");
    t.method("fMaterial!", [](G4LVData* a, G4Material * val) -> G4Material * { return a->fMaterial = val; });

    DEBUG_MSG("Adding fMass methods  to provide read access to the field fMass (" __HERE__ ")");
    // defined in /Users/mato/.julia/artifacts/04a1f392c53fa9913a6e32dc79e45dcf6f1dd250/include/Geant4/G4LogicalVolume.hh:156:14
    // signature to use in the veto list: G4LVData::fMass
    t.method("fMass", [](const G4LVData& a) -> G4double { return a.fMass; });
    t.method("fMass", [](G4LVData& a) -> G4double { return a.fMass; });
    t.method("fMass", [](const G4LVData* a) -> G4double { return a->fMass; });
    t.method("fMass", [](G4LVData* a) -> G4double { return a->fMass; });
    // defined in /Users/mato/.julia/artifacts/04a1f392c53fa9913a6e32dc79e45dcf6f1dd250/include/Geant4/G4LogicalVolume.hh:156:14
    // signature to use in the veto list: G4LVData::fMass
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding fMass! methods to provide write access to the field fMass (" __HERE__ ")");
    t.method("fMass!", [](G4LVData& a, G4double val) -> G4double { return a.fMass = val; });

    DEBUG_MSG("Adding fMass! methods to provide write access to the field fMass (" __HERE__ ")");
    t.method("fMass!", [](G4LVData* a, G4double val) -> G4double { return a->fMass = val; });

    DEBUG_MSG("Adding fCutsCouple methods  to provide read access to the field fCutsCouple (" __HERE__ ")");
    // defined in /Users/mato/.julia/artifacts/04a1f392c53fa9913a6e32dc79e45dcf6f1dd250/include/Geant4/G4LogicalVolume.hh:158:27
    // signature to use in the veto list: G4LVData::fCutsCouple
    t.method("fCutsCouple", [](const G4LVData& a) -> G4MaterialCutsCouple * { return a.fCutsCouple; });
    t.method("fCutsCouple", [](G4LVData& a) -> G4MaterialCutsCouple * { return a.fCutsCouple; });
    t.method("fCutsCouple", [](const G4LVData* a) -> G4MaterialCutsCouple * { return a->fCutsCouple; });
    t.method("fCutsCouple", [](G4LVData* a) -> G4MaterialCutsCouple * { return a->fCutsCouple; });
    // defined in /Users/mato/.julia/artifacts/04a1f392c53fa9913a6e32dc79e45dcf6f1dd250/include/Geant4/G4LogicalVolume.hh:158:27
    // signature to use in the veto list: G4LVData::fCutsCouple
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding fCutsCouple! methods to provide write access to the field fCutsCouple (" __HERE__ ")");
    t.method("fCutsCouple!", [](G4LVData& a, G4MaterialCutsCouple * val) -> G4MaterialCutsCouple * { return a.fCutsCouple = val; });

    DEBUG_MSG("Adding fCutsCouple! methods to provide write access to the field fCutsCouple (" __HERE__ ")");
    t.method("fCutsCouple!", [](G4LVData* a, G4MaterialCutsCouple * val) -> G4MaterialCutsCouple * { return a->fCutsCouple = val; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<G4LVData>> type_;
};
std::shared_ptr<Wrapper> newJlG4LVData(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlG4LVData(module));
}
